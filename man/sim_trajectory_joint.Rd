\name{sim_trajectory_joint}
\alias{sim_trajectory_joint}
\alias{interp_trajectory_joint}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
Simulation and interpolation of trajectories.
}
\description{
\code{sim_trajectory_joint} simulates regular-step trajectories under correlated random walk (CRW).
\code{interp_trajectory_joint} interpolates regular steps to irregular ones drawn from a log-normal distribution.
}
\usage{
sim_trajectory_joint(area_map, centroids=matrix(c(0,0), ncol=2), 
                     transition_matrices=list(matrix(c(10,3,2,9), 
                     ncol=2, byrow=TRUE)), 
                     mu0_pars=list(alpha=c(-4 ,-1.6), beta=c(0,0)), 
                     var0_pars=list(alpha=c(1.6,0.16), beta=c(2,0.5)), 
                     N=100, nstates=2, reg_dt=120, gen_irreg=TRUE, 
                     one_d=FALSE, dt_lnorm_mu=log(120), dt_lnorm_sd=1,
                     dt_vals=NULL, starting_polygon=area_map,
                     nsharks=1, interact=FALSE, 
                     interact_pars=list(interacting_sharks=c(1:nsharks),
                     time_radius=60*30, spat_radius=200, min_num_neibs=10,
                     eta_mu=c(2,1), rho_sd=c(0.75, 0.75)),
                     time_dep_trans=FALSE, trans_alpha=c(1, 1.5)) 

interp_trajectory_joint(d, nstates, one_d, dt_lnorm_mu=5, dt_lnorm_sd=1, 
                        dt_vals=NULL, centroids=matrix(c(0,0), ncol=2))



}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{area_map}{
Shapefile within which the observations are located (optional).
}
  \item{centroids}{
Matrix with two columns specifying the centroids of regions.  The number of rows specifies the number of regions.
}
  \item{transition_matrices}{
A list of 2x2 matrices specifying the Dirichlet parameters for behavior transition probabilities. The list is replicated so it's the length of the number of regions.  If \code{nstates}=1 then these are not used since there is only one behavior. 
}
  \item{mu0_pars}{
List of mean values of alpha (=log-speed if 2-D, and velocity if 1-D) and beta (turn angle, ignored for 1-D) for one or two behavioral states.
}
  \item{var0_pars}{
List of variances of alpha and beta distributions (see \code{mu0_pars}).
}
  \item{N}{
Number of regular steps to simulate.
}
  \item{nstates}{
Number of behavioral states.  For now restricted to a maximum of 2.
}
  \item{reg_dt}{
Length in seconds of each regular interval.
}
  \item{gen_irreg}{
Logical.  If TRUE, then use \code{interp_trajectory_joint} to make irregular steps.
}
  \item{one_d}{
Logical.  If TRUE, then simulation occurs on 1-D line, if FALSE (the default) it is 2-D.
}
  \item{dt_lnorm_mu}{
Mean parameter mu of the log-normal distribution to draw time step lengths.  
}
  \item{dt_lnorm_sd}{
Standard deviation parameter sigma of the log-normal distribution to draw time step lengths.
}  
\item{starting_polygon}{
Polygon to draw starting coordinates in.  This helps if you want the trajectories to start around the same area.
}
\item{nsharks}{
Number of sharks to simulate trajectories for.  If \code{nsharks}>1, then joint effects may take place.
}
  \item{interact}{
Logical.  If TRUE, simulate interaction parameters of neighborhood (either 1-D or 2-D).   If \code{nstates}=1, automatically set to FALSE.
}
  \item{interact_pars}{
List of interaction priors: 1) \code{interacting_sharks} means which of the sharks 1...\code{nsharks} are to use interaction parameters; 2) \code{time_radius} is the time in seconds, and 3) \code{spat_radius} is the spatial radius is meters to consider for spatial neighbors; 4) \code{min_num_neibs} is the minimum number of time and spatial radius observations that need to exist to constitute a neighborhood; 5) \code{eta_mu} is the vector of mean value for the interaction parameter \code{eta}; \code{rho_sd} is the vector of standard deviations of the interaction multiplier rho.
}
 \item{time_dep_trans}{
Logical. If TRUE, state transition matrices are time-dependent meaning that probability depends on the number of steps a shark has remained in the current state.
}
 \item{trans_alpha}{
If \code{time_dep_trans}=TRUE, the transition alpha parameters for the Dirichlet distribution for drawing behaviors.
}
 \item{d}{
Input for \code{interp_trajectory_joint}.  An array, usually output by \code{sim_trajectory_joint}, of regular-step trajectories.
}
 \item{dt_vals}{
An optional vector of time difference values.  By default is NULL, meaning time gaps will be generated by 
\code{dt_lnorm_mu} and \code{dt_lnorm_sd}, but supplying a vector to \code{dt_vals} lets the user specify
the time gaps rather than having them be randomly generated.  
} 
}
\value{
\item{d}{
	Array of regular-step trajectory locations.
}
\item{d_ds}{
	Object \code{d} in format \code{data.frame}.
}
\item{di}{
	If \code{gen_irreg==TRUE}, is the non-constant step length locations.
}
}
\author{
	Samuel Ackerman
}
%% ~Make other sections like Warning with \section{Warning }{....} ~

\examples{
	

#prepare shapefile
bolsachica <- rgdal::readOGR(system.file("shapes/FTB_lines.shp", package="animalEKF")[1])
bcrds <- sp::coordinates(bolsachica)[[ 1 ]][[ 1 ]]
colnames(bcrds) <- c("X","Y")
bolsachica <- vector(mode="list", length=1)
bolsachica[[ 1 ]] <- Polygons(list(Polygon(bcrds)), ID="1")
bolsachica <- SpatialPolygons(bolsachica)

island <- rgdal::readOGR(system.file("shapes/FTB_island.shp", package="animalEKF")[1])
bolsachica@proj4string <- island@proj4string
bolsachica <- rgeos::gDifference(bolsachica, island)
bolsachica@proj4string <- island@proj4string


#define Voronoi tessellation of regions, here randomly selected
regions <- as.data.frame(sp::spsample(x=bolsachica, n=3, type="regular"))

nsharks <- 4

#define Voronoi tessellation in which to start shark paths
vortess <- deldir::deldir(x=regions[,1], y=regions[,2], wlines="tess", 
							plotit=FALSE, suppressMsge=TRUE)
vtiles <- tess2spat(vortess)
vtiles@proj4string <- island@proj4string

#define list of transition matrices between behaviors


tmat_list <- list(matrix(c(8, 2, 2, 4), ncol=2, byrow=TRUE),
                  matrix(c(1.5*5, 1.5*1, 3, 3), ncol=2, byrow=TRUE),
                  matrix(c(7, 1, 1, 7), ncol=2, byrow=TRUE))

#generate 4-shark simulated trajectory with 200 regular steps of length 120 seconds.  
#Sharks 3 and 4 will be interacting with the others, but 1 and 2 will not.
			  
	
		
#simulate trajectory
#setting gen_irreg=TRUE generates an irregular trajectory from the regular-step one
#with the log-normal specified in dt_lnorm_mu and dt_lnorm_sd
#sim_4sharks$di would contain the irregular dataset
#otherwise, say you wanted to try different interpolations, you can use the same regular
#step from sim_trajectory_joint and then interpolate separately with interp_trajectory_joint.

#make simulated trajectories all start in the same area so they will be close enough to be
#interacting, for the purposes of this exercise
#note that the simulation may time out trying to draw points in this starting polygon that end 
#up in the shapefile boundary

# only estimate movement on first 25 steps
# for better results, npart should be set higher, like 150 or more
nsteps_sim <- 200
nsteps_estimate <- 25
npart <- 50
reg_dt <- 120


\donttest{	

sim_4sharks <- sim_trajectory_joint(area_map=bolsachica, centroids=regions, 
                                    transition_matrices=tmat_list, nsharks=nsharks,
                                    mu0_pars=list(alpha=c(-4 ,-1.6), beta=c(0,0)), 
                                    var0_pars=list(alpha=c(1,0.25), beta=c(1,.25)),
                                    N=nsteps_sim, nstates=2, reg_dt=reg_dt,
                                    gen_irreg=FALSE,one_d=FALSE,
                                    starting_polygon=vtiles[ 1 ], interact=TRUE, 
                                    interact_pars=list(interacting_sharks=c(3:4),
                                    time_radius=60*30, spat_radius=150,
                                    min_num_neibs=10,
                                    eta_mu=c(2,1), rho_sd=c(0.75, 0.75)),
                                    time_dep_trans=FALSE, 
                                    dt_lnorm_mu=log(120), dt_lnorm_sd=0.4) 




#plot trajectories

shark_names <- dimnames(sim_4sharks$d)[[ 3 ]]
shark_colors <- 2:5
names(shark_colors) <- shark_names


sp::plot(bolsachica, main="Full trajectories")
deldir::plot.deldir(vortess, wlines="tess", add=TRUE)

for (ss in shark_names) {
    lines(sim_4sharks$d[,c("X","Y"), ss], col=shark_colors[ss])
}
		   
#now interpolate to uneven steps with lognormal mean log(120) (so they are on 
#average the same as the regular steps and sd=0.4
#d is the regular step, di is irregular

#if want to interpolate separately.  Otherwise just set gen_irreg=TRUE above
#this is so you can interpolate a dataset not generated by sim_trajectory_joint
#if gen_irreg=TRUE in sim_trajectory_joint,
#interp_ds will be returned as the 'di' object
				   
interp_ds <- interp_trajectory_joint(d=sim_4sharks$d, nstates=2, 
                                     one_d=FALSE, 
                                     dt_lnorm_mu=log(reg_dt),
                                     dt_lnorm_sd=0.4,
                                     centroids=regions)	



#now plot observed ones, may differ
sp::plot(bolsachica, main="Observed trajectories")
deldir::plot.deldir(vortess, wlines="tess", add=TRUE)

for (ss in shark_names) {
    lines(interp_ds[ interp_ds$tag == ss ,c("X","Y")], col=shark_colors[ss])
}

		
#try to recover EKF with steps at the original 120 seconds
#use the original simulated transition and foraging probabilities for comparison		
		
		
#intial values for some parameters
tau_pars_init <- c(8, 14, 10,1) #2
sigma_pars_init <- c(5, 8, 8, 3)

#measurement error

bmat <- matrix(c(1, -0.3, -0.3, 1), ncol=2)
Errvar_init1 <-5*20*bmat
Errvar_init2 <- 15*20*bmat

#particle error
Particle_err_init <- 0.5*20*bmat
		
		
#again, if you use gen_irreg=TRUE in sim_trajectory_joint,
#the input 'd' argument should be sim_4sharks$di or interp_ds

#NOTE: user should set output_plot=TRUE to see PDF,
#for purposes of package testing we set it to FALSE


ekf_interp_mod <- EKF_interp_joint(d=interp_ds, npart=npart, 
                                   area_map=bolsachica,
                                   state_favor=c(1,2),
                                   centroids=regions, 
                                   sigma_pars=sigma_pars_init,
                                   tau_pars=tau_pars_init,
                                   Errvar0=list(Errvar_init1, Errvar_init2),
                                   Particle_errvar0=Particle_err_init,
                                   mu0_pars=list(alpha=c(-4 ,-1.3), beta=c(0,0)), 
                                   truncate=TRUE, 
                                   neff_sample=0.75, dirichlet_init=c(8,2,2,4), 
                                   smoothing=TRUE, fix_smoothed_behaviors=FALSE, 
                                   time_dep_trans=FALSE, resamp_full_hist=FALSE, 
                                   nstates=2, reg_dt=reg_dt, interact=TRUE, 
                                   maxStep=nsteps_estimate, update_eachstep=TRUE, 
                                   compare_with_known=TRUE, 
                                   known_trans_prob=sim_4sharks$true_transition_prob, 
                                   known_foraging_prob=sim_4sharks$true_foraging_prob, 
                                   known_regular_step_ds=sim_4sharks$d_ds,
                                   output_plot=FALSE)		
				   

#simulate one-dimensional movement for 1 robot (shark)
#here we use gen_irreg=TRUE instead of generating a separate interpolation object

one_d <- sim_trajectory_joint(centroids=NULL, N=nsteps_sim,
                              mu0_pars=list(alpha=c(4, 9)),
                              var0_pars=list(alpha=c(1, 1)),
                              transition_matrices=tmat_list[[ 1 ]], nstates=2,
                              reg_dt=reg_dt, gen_irreg=TRUE, one_d=TRUE,
                              dt_lnorm_mu=log(120), dt_lnorm_sd=0.55)




#measurement error
bmat <- matrix(1)
Errvar_init1 <-1*bmat
Errvar_init2 <-3*bmat


#particle error
Particle_err_init <- 0.1*bmat



ekf_1d <- EKF_1d_interp_joint(d=one_d$di, npart=npart,  maxStep=nsteps_estimate, 
                              state_favor=c(1,1), nstates=2, lowvarsample=TRUE, 
                              neff_sample=1, time_dep_trans=FALSE, reg_dt=reg_dt, 
                              max_int_wo_obs=15, resamp_full_hist=FALSE, 
                              alpha0_pars=list(mu0=c(4, 9), V0=c(0.25, 0.25)),
                              sigma_pars=sigma_pars_init,
                              Errvar0=list(Errvar_init1, Errvar_init2),
                              Particle_errvar0=Particle_err_init,
                              compare_with_known=TRUE, 
                              known_trans_prob=one_d$true_transition_prob, 
                              known_foraging_prob=one_d$true_foraging_prob, 
                              known_regular_step_ds=one_d$d_ds, update_eachstep=TRUE,
                              smoothing=TRUE, output_plot=FALSE)							  
				   
				   
}				   
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ datagen }% use one of  RShowDoc("KEYWORDS")
\keyword{ spatial }% __ONLY ONE__ keyword per line
\keyword{ ts }